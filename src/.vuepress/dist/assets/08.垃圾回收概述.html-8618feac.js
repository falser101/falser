import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as n,c as s,f as e}from"./app-4e52e7a3.js";const i={},t=e(`<blockquote><p>垃圾回收概述</p></blockquote><h2 id="什么是垃圾" tabindex="-1"><a class="header-anchor" href="#什么是垃圾" aria-hidden="true">#</a> 什么是垃圾</h2><h3 id="什么是垃圾-garbage-呢" tabindex="-1"><a class="header-anchor" href="#什么是垃圾-garbage-呢" aria-hidden="true">#</a> 什么是垃圾( Garbage) 呢?</h3><ol><li>垃圾是指在<strong>运行程序中没有任何指针指向的对象</strong>，这个对象就是需要被回收的垃圾。</li><li>外文: An object is considered garbage when it can no longer be reached from any pointer in the running program.</li><li>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。</li></ol><h2 id="为什么需要gc" tabindex="-1"><a class="header-anchor" href="#为什么需要gc" aria-hidden="true">#</a> 为什么需要GC</h2><ol><li>对于高级语言来说，一个基本认知是如果不进行垃圾回收，<strong>内存迟早都会被消耗完</strong>，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</li><li>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便<strong>JVM将整理出的内存分配给新的对象</strong>。</li><li>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，<strong>没有GC就不能保证应用程序的正常进行</strong>。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。</li></ol><h2 id="早期垃圾回收" tabindex="-1"><a class="header-anchor" href="#早期垃圾回收" aria-hidden="true">#</a> 早期垃圾回收</h2><p>在早期的C/C+ +时代，垃圾回收基本上是手工进行的。开发人员可以使用new关键字进行内存申请，并使用delete关键字进行内存释放。比如以下代码:</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code>MibBridge <span class="token operator">*</span>pBridge <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">cmBaseGroupBridge</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//如果注册失败，使用Delete释放该对象所占内存区域</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>pBridge<span class="token operator">-</span><span class="token operator">&amp;</span>gt<span class="token punctuation">;</span><span class="token function">Register</span> <span class="token punctuation">(</span>kDestroy<span class="token punctuation">)</span> <span class="token operator">!=</span> NO_ ERROR<span class="token punctuation">)</span>
<span class="token keyword">delete</span> pBridge<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来<strong>频繁申请和释放内存的管理负担</strong>。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生<strong>内存泄漏</strong>，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成应用程序崩溃。</p><h2 id="java垃圾回收机制" tabindex="-1"><a class="header-anchor" href="#java垃圾回收机制" aria-hidden="true">#</a> Java垃圾回收机制</h2><figure><img src="https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/03/02/kuangstudy438aa976-f556-46ea-bdfd-f89b70034bef.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险 <ul><li>没有垃圾回收器，java也会和cpp-样，各种悬垂指针，野指针，泄露问题让你头疼不已。</li></ul></li><li>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发</li><li>垃圾回收器可以对年轻代回收，也可以对老年代回收，甚至是全堆和方法区的回收。 <ul><li>其中，Java堆是垃圾收集器的工作重点。</li></ul></li><li>从次数上讲: <ul><li><strong>频繁收集Young区</strong></li><li><strong>较少收集Old区</strong></li><li><strong>基本不动Perm区(或元空间)</strong></li></ul></li></ul><h2 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点</h2><ol><li>对于Java开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于自动”，那么这将会是一一场灾难，最严重的就会<strong>弱化Java开发人员在程序出现内存溢出时定位问题和解决问题的能力。</strong></li><li>此时，了解JVM的自动内存分配和内存回收原理就显得非常重要，只有在真正了解JVM是如何管理内存后，我们才能够在遇见OutOfMemoryError时,快速地根据错误异常日志定位问题和解决问题。</li><li>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施<strong>必要的监控和调节</strong>。</li></ol>`,15),o=[t];function r(l,c){return n(),s("div",null,o)}const u=a(i,[["render",r],["__file","08.垃圾回收概述.html.vue"]]);export{u as default};
