import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c,f as n}from"./app-7k_SbfeC.js";const r={},i=n(`<p>〉docker容器与传统虚拟机的区别</p><h1 id="传统虚拟机" tabindex="-1"><a class="header-anchor" href="#传统虚拟机" aria-hidden="true">#</a> 传统虚拟机</h1><p>虚拟机是在宿主机上虚拟一个完整的操作系统，具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。</p><h1 id="docker容器" tabindex="-1"><a class="header-anchor" href="#docker容器" aria-hidden="true">#</a> docker容器</h1><p>与虚拟机是完全不同的两个概念，基于Linux的Namespace和Cgroups实现的，一个正在运行的 Docker 容器，其实就是一个启用了多个 Linux Namespace 的应用进程，而这个进程能够使用的资源量，则受 Cgroups 配置的限制</p><h2 id="linux-namespace概念" tabindex="-1"><a class="header-anchor" href="#linux-namespace概念" aria-hidden="true">#</a> Linux Namespace概念</h2><p>Namespace 的使用方式非常有意思：它其实只是 Linux 创建新进程的一个可选参数。我们知道，在 Linux 系统中创建进程的系统调用是 clone()，比如：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>int pid = clone(main_function, stack_size, SIGCHLD, NULL);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个系统调用就会为我们创建一个新的进程，并且返回它的进程号 pid。而当我们用 clone() 系统调用创建一个新进程时，就可以在参数中指定 CLONE_NEWPID 参数，比如：int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL); 这时，新创建的这个进程将会“看到”一个全新的进程空间，在这个进程空间里，它的 PID 是 1。之所以说“看到”，是因为这只是一个“障眼法”，在宿主机真实的进程空间里，这个进程的 PID 还是真实的数值，比如 100。</p><h2 id="linux-cgroups概念" tabindex="-1"><a class="header-anchor" href="#linux-cgroups概念" aria-hidden="true">#</a> Linux Cgroups概念</h2><p>Docker 是一个基于容器技术的开源平台，它使用了 Linux cgroups 和命名空间（namespaces）等功能来实现轻量级的虚拟化。具体来说，Docker 使用 cgroups 来限制和管理容器中运行的进程组，并为每个容器分配资源限制。</p><p>通过 Docker，我们可以方便地创建、部署和管理应用程序的容器。在底层，Docker 使用了 Linux 内核提供的 cgroups 功能来隔离不同容器之间的资源使用，并确保它们互相之间不会产生干扰。</p><p>因此，可以说 Docker 是建立在 Linux cgroups 机制之上的一种高级工具或接口。它利用了 cgroups 的能力来提供更加简单、灵活和可移植性强的方式来管理和运行应用程序。</p>`,13),s=[i];function o(d,t){return a(),c("div",null,s)}const h=e(r,[["render",o],["__file","02.容器技术概念.html.vue"]]);export{h as default};
